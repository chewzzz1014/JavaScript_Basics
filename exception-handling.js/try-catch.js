"use strict"

// try..catch block to catch runtime error
try{
  alert("Starting...");
  fsffgsrgtrtrhyhhtyj;  // error
  alert("End execution. No Error."); // only execute this line when the code before it (in the try block has no error)
} catch(err){
  alert(err); // ReferenceError: fsffgsrgtrtrhyhhtyj is not defined
  // error message generated by JS engine
}

// put the try..catch block in the scheduled function (eg: setTimeout)

// won't catch the error
try{
  setTimeout(()=> fghstyhty, 1000);
} catch(err){
  alert(err);
}

// will work and catch error
setTimeout( function(){
  try{
    dgggkjoljefoojf;
  } catch (err){
    alert(err); // ReferenceError: dgggkjoljefoojf is not defined
  }
}
, 1000);


// error object has 3 properties: name, message, stack
try{
  jhfbjebhhbfjehfbr;
} catch (err){
  alert(err); // name+message
  alert(err.name);
  alert(err.message);
  alert(err.stack); // call stack of function call
}

// built-in error
// errOccured.name : SyntaxError
// errOccured.message : Check your syntax again
let errOccured = new SyntaxError("Check your syntax again.");

try{
  JSON.parse("{ bad json }");
}
catch(err){
  alert(err.name);  // SyntaxError
  alert(err.message); // Unexpected token b in JSON at position 2
}

// define our own error
// syntax : throw <Error Object>
let json = '{"item": "Milk"}';  // no error

try{
  let onsell = JSON.parse(json);  // no error
  if (!onsell.id) // let's say every item MUST HAVE AN ID
    throw new SyntaxError("Item does not have ID");
}
catch(err){
  alert("JSON Error: "+err.message);
}

// rethrowing : only process error "catch" knows and rethrow all others
// extend the previous code
try{
  let onsell = JSON.parse(json);
  dhbfsdjfdfbhdsfl; // other error
  if (!onsell.id)
    throw new SysntaxError("Item does not have ID");
  dhbfsdjfdfbhdsfl; // other error
}
catch(err){
  if (err instanceof SyntaxError){
    alert("JSON Error: "+err.message);}
  else
      { alert(err); } //ReferenceError: dhbfsdjfdfbhdsfl is not defined
      // since it encountered this error first
}

// try..catch..finally
// finally block will always be executed. Especially useful when we wish to do something no matter whether an error is thrown
function checkIsPositiveInt(n){
  if (n<0 || Math.trunc(n != n))  // negative or non-integer
    throw new Error("Invalid Input.");
  return "Yes!!"; // will not return if error occured
}
let n = +prompt("Enter a positive integer.", 0);

let start = new Date();
try{
  alert(checkIsPositiveInt(n));
} catch (err){
  alert(err);
} finally{
  timeTaken = Date.now() - start;
  alert(`The execution took ${timeTaken} ms.`);
}
